import csv
import os
import sys

from .functions import get_inventory, list_files, human_readable
from .asset import Asset


#=== SUBCOMMAND =============================================================
#         NAME: bytecount
#  DESCRIPTION: count files by extention and sum their sizes
#============================================================================

def bytecount(args):
    '''Sum the bytes in an inventory file or a directory tree, reporting total 
       bytes and number of files broken down by extension.'''
    print("Loading data from specified path...")
    PATH = args.path
    all_files = get_inventory(PATH)
    if not all_files:
        print(
            "ERROR: Could not read inventory data from the specified path.\n"
            )
        sys.exit()

    extensions = {}
    totalbytes = 0

    # Iterate over the rows of the inventory
    for f in all_files:
        totalbytes += int(getattr(f, 'bytes'))
        ext = getattr(f, 'extension')
        if ext in extensions:
            extensions[ext] += 1
        else:
            extensions[ext] = 1

    exts_summary = [
        "{0}:{1}".format(type, num) for (type, num) in extensions.items()
        ]

    # Convert bytes to human-readable if requested and report results
    if args.human and totalbytes >= 1024:
        count_num, count_units = human_readable(totalbytes)
        print('{0} bytes ({1} {2}) for {3} files.'.format(
            str(totalbytes), count_num, count_units, len(all_files)
            ))       
    else:
        print('{0} bytes for {1} files.'.format(
            str(totalbytes), len(all_files)
            ))

    print('({0})'.format(", ".join(exts_summary)))
    print('')


#=== SUBCOMMAND =============================================================
#         NAME: compare
#  DESCRIPTION: check for the presence of files in inventories of various
#               formats (TSM backup, file analyzer, this script)
#============================================================================

def compare(args):
    '''Compare lists of files derived from inventories in various formats,
       including archiving reports from TSM, tab-delimited File Analyzer
       reports, and inventories generated by this script.'''
    filelists = {}
    all_files = [args.first] + args.other 
    for filepath in all_files:
        result = []
        with open(filepath, 'r') as f:
            rawlines = [line.strip('\n') for line in f.readlines()]
            if rawlines[0] == "IBM Tivoli Storage Manager":
                print("Parsing Tivoli output file...")
                p = re.compile(r"([^\\]+) \[Sent\]")
                for line in rawlines:
                    if 'Normal File-->' in line:
                        m = p.search(line)
                        if m:
                            result.append(m.group(1))
            elif "Key" in rawlines[0] or "Filename" in rawlines[0]:
                print("Parsing DPI inventory file... ", end='')
                if '\t' in rawlines[0]:
                    print('tab delimited:')
                    delimiter = '\t'
                else:
                    print('comma delimited:')
                    delimiter = ','
                reader = csv.DictReader(rawlines, delimiter=delimiter)
                filenamecol = "Key" if "Key" in rawlines[0] else "Filename"
                dircol = "Directory"
                for l in reader:
                    result.append(os.path.join(l[filenamecol], l[dircol]))
            else:
                print("Unrecognized file type ...")
            if result:
                filelists[filepath] = result
                print(" => {0}: {1} files".format(filepath, len(result)))
            else:
                print(" => File {0} has not been parsed.".format(filepath))

    all_lists = [set(filelists[filelist]) for filelist in filelists]
    common = set.intersection(*all_lists)
    print("{} values are common to all the supplied files:".format(
            len(common)))

    for n, filelist in enumerate(filelists):
        unique = set(filelists[filelist]).difference(common)
        print(" => File {0}: {1} values are unique to {2}".format(
                n+1, len(unique), filelist))
        if unique is not None:
            sorted_files = sorted(unique)
            for fnum, fname in enumerate(sorted_files):
                print("     ({0}) {1}".format(fnum+1, fname))
    print('')

    
#==== SUBCOMMAND=============================================================
#         NAME: compare
#  DESCRIPTION: check for the presence of files in inventories of various
#               formats (TSM backup, file analyzer, this script)
#============================================================================

def compare(args):
    '''Compare lists of files derived from inventories in various formats,
       including archiving reports from TSM, tab-delimited File Analyzer
       reports, and inventories generated by this script.'''
    filelists = {}
    all_files = [args.first] + args.other 
    for filepath in all_files:
        result = []
        with open(filepath, 'r') as f:
            rawlines = [line.strip('\n') for line in f.readlines()]
            if rawlines[0] == "IBM Tivoli Storage Manager":
                print("Parsing Tivoli output file...")
                p = re.compile(r"([^\\]+) \[Sent\]")
                for line in rawlines:
                    if 'Normal File-->' in line:
                        m = p.search(line)
                        if m:
                            result.append(m.group(1))
            elif "Key" in rawlines[0] or "Filename" in rawlines[0]:
                print("Parsing DPI inventory file... ", end='')
                if '\t' in rawlines[0]:
                    print('tab delimited:')
                    delimiter = '\t'
                else:
                    print('comma delimited:')
                    delimiter = ','
                reader = csv.DictReader(rawlines, delimiter=delimiter)
                filenamecol = "Key" if "Key" in rawlines[0] else "Filename"
                dircol = "Directory"
                for l in reader:
                    result.append(os.path.join(l[filenamecol], l[dircol]))
            else:
                print("Unrecognized file type ...")
            if result:
                filelists[filepath] = result
                print(" => {0}: {1} files".format(filepath, len(result)))
            else:
                print(" => File {0} has not been parsed.".format(filepath))

    all_lists = [set(filelists[filelist]) for filelist in filelists]
    common = set.intersection(*all_lists)
    print("{} values are common to all the supplied files:".format(
            len(common)))

    for n, filelist in enumerate(filelists):
        unique = set(filelists[filelist]).difference(common)
        print(" => File {0}: {1} values are unique to {2}".format(
                n+1, len(unique), filelist))
        if unique is not None:
            sorted_files = sorted(unique)
            for fnum, fname in enumerate(sorted_files):
                print("     ({0}) {1}".format(fnum+1, fname))
    print('')



#=== SUBCOMMAND =============================================================
#         NAME: inventory
#  DESCRIPTION: Generates a file listing with checksum, file size, timestamp
#============================================================================

def inventory(args):
    '''Create a CSV inventory of file metadata for files in 
       a specified path.'''     
    if args.outfile:
        OUTFILE = os.path.abspath(args.outfile)
        if os.path.isfile(OUTFILE):
            print("ERROR: The output file exists.",
                  "Use the -e flag to resume the job.\n")
            sys.exit()
        elif os.path.isdir(OUTFILE):
            print("ERROR: The specified output path is a directory.\n")
            sys.exit()
    elif args.existing:
        OUTFILE = os.path.abspath(args.existing)
        if not os.path.isfile(OUTFILE):
            print("ERROR: Must specify the path to an existing",
                  "inventory file.\n")
            sys.exit()
    else:
        OUTFILE = None

    if os.path.exists(args.path):
        PATH = os.path.abspath(args.path)
    else:
        print("ERROR: The specified search path does not exist.\n")
        sys.exit()

    FIELDNAMES = ['PATH', 'DIRECTORY', 'FILENAME', 
                  'EXTENSION', 'BYTES', 'MTIME', 
                  'MODDATE', 'MD5', 'SHA1', 'SHA256'
                  ]

    # Get a list of all files in the search path.
    all_files = list_files(PATH)
    total = len(all_files)
    files_to_check = all_files  # overriden if outfile specified
    existing_entries = []       # overriden if outfile specified
    count = 0

    if OUTFILE:
        print("Checking path: {0}".format(PATH))
        print("Writing to file: {0}".format(OUTFILE))

        # If the output file exists, read it and resume the job.
        if os.path.isfile(OUTFILE):
            existing_entries = get_inventory(OUTFILE)
            all_keys = set().union(
                *(e.__dict__.keys() for e in existing_entries)
                )

            # if the CSV file conforms to the pattern
            if all_keys.issubset([fname.lower() for fname in FIELDNAMES]):
                files_done = [os.path.join(f.directory, f.filename) \
                                for f in existing_entries]

                # Handle various problem cases
                if files_done == files_to_check:
                    print("Inventory is already complete.\n")
                    sys.exit()
                elif set(files_done).difference(files_to_check):
                    print("ERROR: Existing file contains references",
                          "to files that are not found in the path",
                          "being inventoried.\n")
                    sys.exit()

                files_to_check = set(all_files).difference(files_done)

            # Handle non-conforming CSV file
            else:
                print("ERROR: The specified output file is not a correctly",
                      "formatted inventory CSV.\n")
                sys.exit()

        buffer = 1
        fh = open(OUTFILE, 'w+', buffer)

    # If no output file has been specified, write to stdout
    else:
        fh = sys.stdout

    writer = csv.DictWriter(fh, fieldnames=FIELDNAMES)
    writer.writeheader()
    # Write the existing portion of the inventory to the output file
    if OUTFILE:
        for entry in existing_entries:
            writer.writerow({k.upper():v for (k,v) in entry.__dict__.items()})
            count += 1

    # check each (remaining) file and generate metadata
    for f in files_to_check:
        a = Asset.from_filesystem(f)
        writer.writerow({k.upper(): v for k, v in a.__dict__.items()})
        count += 1
            
        if OUTFILE:
            # display running counter
            print("Files checked: {0}/{1}".format(count, total), end='\r')

    if OUTFILE:
        fh.close()
        # clear counter
        print('')
        # report successful completion
        print('Inventory complete!')
        print('')


#=== SUBCOMMAND =============================================================
#         NAME: verify
#  DESCRIPTION: verify two sets of files (on disk or as recorded in CSV file) 
#               by comparing their checksums, size, timestamp
#============================================================================

def verify(args):
    '''Verify the identity of two inventories (either stored or created on 
       the fly), by checking for the presence of all files and comparing the 
       checksums of each one.'''
    print("1. Loading data from 1st path...")
    dict_a = {f.path: f.md5 for f in get_inventory(args.first)}
    print("2. Loading data from 2nd path...")
    dict_b = {f.path: f.md5 for f in get_inventory(args.second)}
    all_keys = set().union(dict_a.keys(), dict_b.keys())
    not_a = []
    not_b = []
    changed = {}
    verified = 0
    total = len(all_keys)

    # Iterate over union of both file inventories
    for n,k in enumerate(all_keys):
        if not k in dict_a:
            not_a.append(k)
        elif not k in dict_b:
            not_b.append(k)
        elif not dict_a[k] == dict_b[k]:
            changed[k] = (dict_a[k], dict_b[k])
        else:
            verified += 1
        print("Checked {0}/{1} files.".format(n+1, total), end='\r')

    # Clear counter
    print('')

    # Report success or failure of verification
    if not any([not_a, not_b, changed]):
        print("Success! No differences found.")
    else:
        print("Possible problems were found.")

    # Report details of the comparison
    print("  => {0} files are in 1 but not 2.".format(len(not_b)))
    print("  => {0} files are in 2 but not 1.".format(len(not_a)))
    print("  => {0} files show a checksum mismatch.".format(len(changed)))
    for k,v in changed.items():
        print("     - {0}: {1} != {2}".format(k, v[0], v[1]))
    print("  => Verified {0}/{1} files.".format(verified, total))
    print('')
